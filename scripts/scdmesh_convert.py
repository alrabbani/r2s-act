#!/usr/bin/env python

"""A tool to convert hexahedral meshes to ScdMesh structured meshes"""

from itertools import izip
import optparse

import scdmesh
from itaps import iBase, iMesh, iMeshExtensions

def extract_dimensions( mesh, meshset ):
    """Given a meshset within a mesh, determine its vertex grid
    
    Return a list of three sets: the unique values of the x, y, and z, coordinates
    of the vertices in the given set."""
    dimsets = [set(), set(), set()]
    for vtx in meshset.iterate( iBase.Type.vertex, iMesh.Topology.point ):
        xyz = mesh.getVtxCoords( vtx )
        for idx, val in enumerate(xyz):
            dimsets[idx].add( val )
    return dimsets

def convert_mesh( mesh1, meshset1, mesh2, **kw ):
    """Convert a bunch of hexahedra in an EntitySet to a ScdMesh

    Take the hexahedra of meshset1 (in the iMesh.Mesh object mesh1) and return 
    a ScdMesh containing them.  Data are copied into the iMesh.Mesh instance mesh2,
    which may be equal to mesh1.

    All tags set on the hexahedra of the input mesh will be duplicated in the output mesh,
    and all tags on meshset1 will be added to the scdset of the new ScdMesh

    Keyword args:
        order: The underlying order of the hexahedra in the input mesh.  This is a string
               with the same valid values as the order argument in ScdMesh.iterate().
               The default ordering is xyz, for compatibility with meshes generated by
               mmGridGen and by earlier versions of FluxParse.py
    """
    try:
        t = mesh1.getTagHandle('BOX_DIMS')
        t[meshset1]
        raise scdmesh.ScdMeshError('Cannot convert an existing ScdMesh to ScdMesh.')
    except iBase.TagNotFoundError:
        pass

    dims = extract_dimensions( mesh1, meshset1 )
    dims = [list(sorted(x)) for x in dims]

    sm = scdmesh.ScdMesh( mesh2, *dims )
    
    # We want to copy all tags set on hexes; figure out what they are by 
    # checking meshset1's first hex for tags
    tags1 = mesh1.getAllTags( meshset1.iterate(iBase.Type.region,
                                               iMesh.Topology.hexahedron).next() )
    if mesh1 is not mesh2:
        tags2 = []
        for t in tags1:
            tt = mesh2.createTag(t.name, t.sizeValues, t.type)
            tags2.append( tt )
    else:
        tags2 = tags1

    for (t1,t2) in zip(tags1,tags2):
        for e1, e2 in izip( meshset1.iterate(iBase.Type.region, 
                                             iMesh.Topology.hexahedron ),
                            sm.iterateHex( kw.get('order','xyz') )):
            t2[e2] = t1[e1]

    settags1 = mesh1.getAllTags( meshset1 )
    for t in settags1:
        if mesh1 is not mesh2:
            # different iMesh instances; create a new tag in mesh2
            tt = mesh2.createTag(t.name, t.sizeValues, t.type)
            tt[sm.scdset] = t[meshset1]
        elif meshset1 == mesh1.rootSet:
            # mesh1 and mesh2 are the same, but the given set is the root set 
            # of mesh1, meaning the tag cannot be set on the scdset.  Do nothing,
            # since the tag remains global.
            pass
        else:
            # mesh1 and mesh2 are the same, and this tag can be validly set on
            # entity sets, so set it on sm.scdset
            t[sm.scdset] = t[meshset1]

    return sm

def main():
    op = optparse.OptionParser( 
            usage='%prog [options] filename', 
            description='A tool to convert old structured meshes to ScdMeshes.'
                        '  Eligible inputs include meshes created by mmGridGen'
                        ' and FluxParse.py') 
    op.add_option( '-o', default='converted_scdmesh.h5m',
                   help='Output file name, default: %default',
                   dest='outputfile' )

    opts, args = op.parse_args()
    if len(args) != 1:
        op.error( 'Need exactly one argument: filename to load' )

    mesh = iMesh.Mesh()
    mesh.rootSet.load( args[0] )

    mesh2 = iMesh.Mesh()
    sm = convert_mesh( mesh, mesh.rootSet, mesh2 )
    sm.scdset.save( opts.outputfile )

if __name__=='__main__':
    main()
