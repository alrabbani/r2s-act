A: [geom & materials ] --> neutron transport == DAGMC
B: neutron transport --> [ neutron flux ] == MCNP mesh tally

C: [geom & mat'ls] --> ALARA

* relies on mmGridGen and has its limitations
     * single coarse mesh region in each dimension
     * Cartesian
* relies on meshReader utility
     * limited to single format of mmGridGen output
     * could/should be reimplemented in python
     * dumps all necessary info in ASCII text
* python script converts output of meshReader to ALARA input input blocks
     * volume, mat_loading, mixture
     * one mixture definition for every mesh element that is not void - even if multiple voxels with identical material
     * assumes at matlib definition for each MCNP material defined in the problem (mat_1, mat_2, ...)
            * built by hand

D: [neutron flux] --> ALARA

* python script that converts meshtal to alara fluxin
* native meshtallies (meshtal) only - Cartesian & Cylindrical
* established convention on the ordering of fluxes - same as the order in meshtal
    * x - y - z - E
    * r - z - t - E (check?)
* energy order can be either increasing or decreasing - default is increasing
* no support for standard tallies (mctal/outp)

E: ALARA --> [gamma src]

* native ALARA capability
* updated for better parsing and filtering
* established an ordering: voxel - isotope (incl. Total) - cooling time
     * voxel ordering is identical to flux/volume input ordering

F: [gamma src] --> photon transport

* SDEF methodology
* python script will
     * parse/filter for the photon source E distribution for a given cooling time and Total over all isotopes
     * generates a histogram distribution for sampling the energy in each voxel
     * calculate the centroid of each voxel
     * generates a discrete distrubtion to sample which voxel centroid to use
     * generate SDEF card and all distributions to accomplish this

* source.F90 (untested - not working)
* based on KIT contribution
* python script will
     * parse/filter for the photon source E distribution for a given cooling time and Total over all isotopes     
     * Generates a cumulative histogram distrubtion for sampling the energy in each voxel
* this should allow KIT source.F90 to function completely


Retrospective
----------------------------------------
* visualization is lacking for: [neutron flux], [material fractions], [photon source]
* DE/DF flux to dose conversions
* more streamlining of process - a single script that runs the whole process
* ALARA material library matching  - need to have a matlib entry for each MCNP entry
* confusion on neutron data - energy order, number of groups, etc


Planning
---------------------
Step 1: Develop tools to arrive at a single mesh file (h5m) tagged with both flux and material data

1a: mmGridGenOut + meshtal file ==> pyTaps script ==> h5m(flux,mat'l)
     * any pyTaps script that reads mesh
     * EB script that reads meshtal
     * new code to find meshtal voxel in pyTaps mesh element list
     * save flux info to pyTaps tags
     * write mesh

1b: meshtal file ==> pyTaps script ==> h5m(flux) + CAD geometry ==> mmGridGen(modified) ==> h5m(flux,mat'l)
     * new pyTaps based meshtal reader
     * new mmGridGen mesh generator
     * new mesh skin traversal

Step 2: Develop tools to generate ALARA input from a single mesh file (h5m) tagged with both flux and materiald ata

2a: h5m(flux,mat'l) ==> python meshReader + EB script + AJ script ==> ALARA snippets + fluxin
     * any pyTaps script that reads mesh
     * new code to handle different mmGridGen conventions
     * write fluxin (from EB script)
     * write ALARA snippets (from AJ script)

2z: modify ALARA to directly read h5m(flux,mat'l)
     * distant future

Step 3: Develop tools to generate KIT source.F90 input from ALARA photon source file & h5m(flux,mat'l)

3a: ALARA photon source + h5m(flux,mat'l) ==> pyTaps script ==> h5m(flux,mat'l, src)
     * looks a lot like 1a
     * any pyTaps script that reads mesh
     * ER script that reads ALARA photon_src file
     * new code to corelate photon_src with pyTaps mesh element (convention?)
     * save photon source to pyTaps tags
     * write mesh

3b: h5m(flux,mat'l, src) ==> pyTaps script ==> source.F90 input information
     * document source.F90 input needs
     * pyTaps script that read mesh
     * ER script that writes "gammas" file
     * ?where is mesh geometry info?

3m: modify source.F90 to read h5m(flux,mat'l,src)
     * many research questions will remain unanswered today
